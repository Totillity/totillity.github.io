<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Book</title>
    
        <link rel='stylesheet' href='../../style.css'>
    
</head>
<body>
    <input type="checkbox" class="nav-bar-side-checkbox" id="nav-bar-side-button">
    <div class="nav-bar-side">
        <div class="nav-bar">
            <div id="nav-title-container">
                <img src="/Logo.svg" id="nav-img" alt="Pretty logo">
            </div>

            <div class="nav-list">
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/index.html">Contents</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        
                            <input type="checkbox" class="nav-checkbox" id="nav-checkbox-1-2" checked="checked">
                        
                        <div class="nav-bar-dropdown-container">
                            <label class="nav-label" for="nav-checkbox-1-2">
                                <span class="nav-dropdown-label-span">
                                    JIT Project
                                </span>
                            </label>
                            <div class="nav-dropdown-content">
                                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/about.html">About</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        
                            <input type="checkbox" class="nav-checkbox" id="nav-checkbox-2-2" checked="checked">
                        
                        <div class="nav-bar-dropdown-container">
                            <label class="nav-label" for="nav-checkbox-2-2">
                                <span class="nav-dropdown-label-span">
                                    Progress Timeline
                                </span>
                            </label>
                            <div class="nav-dropdown-content">
                                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/timeline.html">Timeline</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/week-1-3.html">Weeks 1 to 3</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/journal-1.html">Journal 1</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/week-4-7.html">Weeks 4 to 7</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/journal-2.html">Journal 2</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/week-8-13.html">Weeks 8 to 13</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/journal-3.html">Journal 3</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/week-14-15.html">Weeks 14 to 15</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/journal-4.html">Journal 4</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/week-16-19.html">Weeks 16 to 19</a>
                    
                    </div>
                
                    <div class="nav-bar-item">
                    
                        <a class="nav-link" href="/jit-project/progress-timeline/journal-5.html">Journal 5</a>
                    
                    </div>
                
                            </div>
                        </div>
                    
                    </div>
                
                            </div>
                        </div>
                    
                    </div>
                
            </div>
        </div>
        <label class="nav-bar-side-label" for="nav-bar-side-button">
            <span class="nav-bar-side-label-span"></span>
        </label>
    </div>
    <div class="content-container">
        <div class="content">
            <div class="content-title"><header>Journal 3: Weeks 8-13</header></div><hr><div class="content-paragraph"><p>January 15, 2020 - February 27, 2021</p></div><div class="content-heading">Goals for this Journal:</div><ol class="content-ordered-list"><li class="content-ordered-list-item"><div class="content-paragraph"><p>Research some non-JIT optimization techniques</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Research some JIT specific optimization techniques</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Whenever I find one I want to implement, do so</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Implemented include: Dead Code Elimination, Constant Folding, Instruction Emission Optimization</p></div></li></ol><div class="content-heading">Research</div><div class="content-paragraph"><p>
<b>Note: all references labelled at the bottom.</b>
<b>Note: I used code snippets instead of screenshots because this is a programming project.</b>
<b>Note: I used pseudocode instead of actual C for the sake of clarity.</b></p></div><div class="content-paragraph"><p>Originally, this journal was to be primarily focused on my initial efforts to implement the parts of a JIT that make it a JIT.
However, there is an issue with that: those parts don't work until I do some preliminary work that makes it more of an AOT compiler
than a jit. Therefore, this journal will cover the AOT optimization techniques I've implemented, and the initial work to implement
the JIT part.</p></div><div class="content-paragraph"><p>First, I'll explain the basic idea of code optimization. Say a programmer wrote this code:   
</p></div><div class="content-code"><pre>
def foo() {
    a = 7 * 3
    b = a + 4
    c = b + a
    return c
}
</pre></div><div class="content-paragraph"><p>
It is very easy for a human to see that all this work of addition and multiplication doesn't need to be done everytime
this code is run. The loads, multiplications, additions, and stores would create a lot of extra work that doesn't need to be
done. Rather, the following code would have the exact same end result, but would run significantly faster:
</p></div><div class="content-code"><pre>
def foo() {
    return 46
}
</pre></div><div class="content-paragraph"><p>
This change has removed 3 variables and 3 operations, making it an excellent <i>optimization</i>. As you've probably guessed,
an optimization is simply any change to a program which makes it have the same result, but use less of some valuable resource,
such as time, I/O, or memory. A compiler optimization is any routine within the compiler which attempts to optimize the code it
is given in some particular way. An optimization is a particular strategy to optimize code.
</p></div><div class="content-paragraph"><p>
The hard part of all this, of course, is getting a computer to understand a program well enough that it can make it better.
This can be an extremely challenging thing to do, if you do it naively. Take the following code: 
</p></div><div class="content-code"><pre>
def bar() {
    x = 7 + 2
    y = x * 2 + x
    x = y - 3
    z = x * y - y
    return z + x
}
</pre></div><div class="content-paragraph"><p>
Say you create an optimization where, whenever an arithmetic operation is applied to two constants and assigned to a variable (think 
<span class="nowrap"><code>a = 3 - 2</code></span> or <span class="nowrap"><code>k = 55 / 5</code></span>),
you replace all usages of that variable with the result of said arithmetic operation. You then apply that optimization to the above code once, 
getting:  
</p></div><div class="content-code"><pre>
def bar() {
    // we know x = 7 + 2 = 9, so we remove the assignments to x and replace its usages with 9
    y = 9 * 2 + 9
    // this line (x = y - 3) can be removed, right???
    z = 9 * y - y
    return z + 9
}
</pre></div><div class="content-paragraph"><p>
You might have seen the problem. Halfway through the function, we assign to x again, this time with a possibly different value.
Any usages of x after that point have to refer to a different value. We can't just naively replace variables whenever we want.
<i>Or can we?</i>
</p></div><div class="content-paragraph"><p>
SSA is a solution to this problem. It stands for Static Single Assignment form, but only the 'Single Assignment' part is what we care about.
In SSA form, all variables are assigned to only once. The function I've shown above would not be a valid SSA program, because
x is assigned to twice. However, it is fairly trivial to convert a non-SSA program to SSA form. Whenever you would assign to a variable
for the second time, like in the <span class="nowrap"><code>x = y - 3</code></span> line, instead assign to a new variable and replace all future occurrences of the
original variable with the new one. For example, here's the previous function converted to SSA form:
</p></div><div class="content-code"><pre>
def bar() {
    x = 7 + 2
    y = x * 2 + x
    x1 = y - 3
    z = x1 * y - y
    return z + x1
}
</pre></div><div class="content-paragraph"><p>
As you can see, the x1's solve the problem of the same variable having different values in different parts of the program
Now, replacing variables with what we know is their constant value is much easier, especially for
the dumb computer. This shows just some of the value of SSA form. Now let's go over some optimizations. 
</p></div><div class="content-paragraph"><p>
<b>Constant Folding</b> is one of the simplest optimizations to understand, as it's the one I've been using as an example.
It's just replacing operations we know are on constants with their known result. Usually, multiple passes of this optimization are 
advisable. After just one iteration of <span class="nowrap"><code>bar</code></span> from above (replacing x), it becomes:
</p></div><div class="content-code"><pre>
def bar() {
    y = 9 * 2 + 9
    x1 = y - 3
    z = x1 * y - y
    return z + x1
}
</pre></div><div class="content-paragraph"><p>
Knowing that more optimizations can be performed, we do a second iteration on the new code generated, replacing y, so it becomes: 
</p></div><div class="content-code"><pre>
def bar() {
    x1 = 18 - 3
    z = x1 * 18 - 18
    return z + x1
}
</pre></div><div class="content-paragraph"><p>
We can now replace x1, which makes our third iteration: 
</p></div><div class="content-code"><pre>
def bar() {
    z = 15 * 18 - 18
    return z + 15
}
</pre></div><div class="content-paragraph"><p>
Finally, on the 4th iterations, we've removed all variables and calculations: 
</p></div><div class="content-code"><pre>
def bar() {
    return 267
}
</pre></div><div class="content-paragraph"><p>
Constant folding has converted a function with lots of variables, operations, and general overhead into a near-zero cost function.
To actually execute this optimization, we just recognize whenever both arguments to an arithmetic operation are either constants, or
variables we know are constant.
</p></div><div class="content-paragraph"><p>
<b>Dead Code Elimination (DCE)</b> is an optimization which removes unused instructions. To see the usefulness of this,
I have to reveal that I've lied. Constant folding does not remove the assignments to variables we know are constant. It just 
replaces its usages, but not its definition, since that's not part of what it's supposed to do. Rather, Constant Folding defers
all useless-code removal to the DCE optimization.   
</p></div><div class="content-paragraph"><p>
DCE is a fairly simple optimization to understand; my previous definition just about sums it up. The primary way that this
pass detects what code is 'dead' is by seeing what variables are never accessed after they are assigned, which is obviously 
trivial to write as a computer program when the code to optimize is in SSA form. This would obviously be the case in the 
aftermath of the Constant Folding pass, when the variables have been turned into constants. In that case, then 
assignments can be removed.
</p></div><div class="content-paragraph"><p>
Unfortunately, removing dead code isn't quite as simple as destroying all unused variables. There is the possibility
that some code assigns some value to a variable, but that value was calculated in some way which has <b>side effects</b>.
Side effects are when some code has effects other than computing a value, like printing something to the screen or setting an
element of an array. In this case, removing code with side-effects just because its return value isn't used would fundamentally 
change the program, which isn't what we want to do. So a DCE pass would need to detect when some code has side effects and
only remove code which doesn't. This can be approximated by not just not removing function calls, which may or may not have side 
effects. 
</p></div><div class="content-paragraph"><p>
<b>Instruction Emission Optimization (IEO)</b> is my name for a practice which has many different names, mostly due to
how ubiquitous it is. The heart of this optimization is using the shortest/faster version of an Assembly instruction.
To see this in action, let's examine a case where we want to add the constant 45 to a variable which is currently stored in the
general purpose register RAX. The most obvious way to do so is with the following assembly: 
</p></div><div class="content-code"><pre>
MOV RCX, 45
ADD RAX, RCX
</pre></div><div class="content-paragraph"><p>
First, lets explain a bit about assembly. In x86 assembly, which is the instruction set most desktop computers use 
(as opposed to ARM, which is seen more in smart devices such as iPhones and microwaves), most instructions take two arguments. 
For instructions such as MOV, this makes sense. The line <span class="nowrap"><code>MOV RCX, 45</code></span> <b>mov</b>es the constant 45 to RCX. 
In other words, the register RCX is set to 45. If the line was instead <span class="nowrap"><code>MOV RCX, RBX</code></span>, then the value 
inside RBX is copied into RCX. We need a destination and a source, which fits into two arguments.
</p></div><div class="content-paragraph"><p>
However, the two=argument paradigm doesn't work so well when you come to instructions such as ADD. Here, you would think
you need 3 arguments, two for the actual things to add together and one to tell the computer where to put the result.
x86 gets around the problem by saying that the first argument is both one of the arguments, as well as the location to 
put the result. In simpler terms, the second argument is added into the first. Therefore <span class="nowrap"><code>ADD RAX, RCX</code></span>
takes the values in RAX and RCX, adds them together, and stores the result in RAX.
</p></div><div class="content-paragraph"><p>
Together, these two instructions accomplish what we've set out 3 paragraphs ago. <span class="nowrap"><code>MOV RCX, 45</code></span> puts 45 into 
RCX, which isn't currently used. Then, <span class="nowrap"><code>ADD RAX, RCX</code></span> adds that 45 into RAX, our variable. We've added 45 to
our variable. However, it turns out that there is a shorter way to accomplish all of this.
</p></div><div class="content-paragraph"><p>
x86 provides for a form of ADD where the second argument is directly a constant. This makes the constant an <b>immediate</b>
because the cpu can immediately load that constant. In any case, if we use this new form of the ADD instruction, then we 
can eliminate the MOV entirely, cutting the instructions used in half, resulting in <span class="nowrap"><code>ADD RAX, 45</code></span>. 
Additionally, we also cut the registers used to 0 new ones, saving RCX to be used elsewhere. Either effect would result 
in a speed-up, but combined, we see an even larger performance increase.
</p></div><div class="content-paragraph"><p>
This isn't all we can do in the field of IEO. But to see this next layer of it, we'll need to examine how assembly is encoded.
Somewhat obviously, computers don't run on text files. Opening up an executable in Notepad will show that, as Notepad will
give up on displaying the contents as actual text. Instead, computers take in raw bytes. The assembler's job is to transform
assembly code such as <span class="nowrap"><code>ADD RAX, RCX</code></span> or <span class="nowrap"><code>MOV RCX, 45</code></span> into bytes that the computer can understand.
I've written a simple assembler for my project, and we can examine it some more here.
</p></div><div class="content-paragraph"><p>
Intel is kind enough to provide a 2000+ page <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">manual</a>
on how x64 (the extension of x86 to 64-bit computers) is encoded.
Their first page on the MOV instruction (pg 687) provides a large table, which explains how each form of the MOV instruction,
such as the form with 2 registers as arguments, the form with 1 register and 1 memory location, the form with 1 memory
location and 1 constant, etc. are encoded. Let's look at a sample, which is the form with 
</p></div><div class="content-code"><pre>
       Opcode       |    Instruction   |     |    Description
--------------------+------------------+ ... +--------------------
  REX.W+ B8 +rd io  |  MOV r64, imm64  |     | Move imm64 to r64
</pre></div><div class="content-paragraph"><p>
Let's dissect the first two columns. The <b>Instruction</b> column tells us exactly what this
instruction is used for. The <span class="nowrap"><code>MOV</code></span> tells us that this instruction is some type of MOV instruction, which 
copies data into other locations. The <span class="nowrap"><code>r64, imm64</code></span> tells us the two arguments to the instruction, where 
<span class="nowrap"><code>r64</code></span> is the first argument and <span class="nowrap"><code>imm64</code></span> is the second. The <span class="nowrap"><code>r</code></span> in <span class="nowrap"><code>r64</code></span>
tells us that the first argument is a register, and the <span class="nowrap"><code>64</code></span> tells us that it specifically assigns to the 
64 bit version of that register. The <span class="nowrap"><code>imm64</code></span> tells us that the second argument is a <b>64</b> bit <b>imm</b>ediate.  
In total, this column tells us that this row refers to the form of the MOV instruction where it takes a 64 bit register 
and a 64 bit immediate. 
</p></div><div class="content-paragraph"><p>
The real meat is in the <b>Opcode</b> column, which tells you what bytes must be written to encode this form of the instruction. 
There are 4 distinct terms in <span class="nowrap"><code>REX.W+ B8 +rd io</code></span>. <span class="nowrap"><code>REX.W+</code></span> tells us that the encoding must
start with the REX byte. The REX byte is something new to x64, which serves the purpose of providing the extra data
needed to make this instruction 64-bit instead of 32-bit (I'll expend on this later). It takes the form <span class="nowrap"><code>0 1 0 0 w r x b</code></span>,
where <span class="nowrap"><code>0 1 0 0</code></span> is a set sequence that marks this byte as a REX prefix, and <span class="nowrap"><code>w</code></span>, 
<span class="nowrap"><code>r</code></span>, <span class="nowrap"><code>x</code></span>, and <span class="nowrap"><code>b</code></span> are one bit flags. <span class="nowrap"><code>REX.W+</code></span> 
means that the <span class="nowrap"><code>w</code></span> bit should be set, which tells the CPU that this is a 64 bit version of an instruction 
that is normally 32 bit. <span class="nowrap"><code>B8 +rd</code></span> are two 
separate terms which should be interpreted together. Normally, <span class="nowrap"><code>B8</code></span> would provide the instruction code,
which is what tells the CPU what instruction these bytes are referring to. However, the extra <span class="nowrap"><code>+rd</code></span> tells
us that the CPU can infer the instruction (MOV r64, imm64) just from the first 5 bits of the <span class="nowrap"><code>B8</code></span> byte (which
is <span class="nowrap"><code>1 0 1 1 1 0 0 0</code></span> in total),
and that we can therefore encode the register in the last 3 bits. RAX, for example, has the code, in bits, <span class="nowrap"><code>0 0 0 0</code></span>.
R12 has the code, in bits, <span class="nowrap"><code>1 1 0 0</code></span>. We take the last 3 bits and stick them onto the end of <span class="nowrap"><code>B8</code></span>
to specify the register. The byte would therefore be just <span class="nowrap"><code>B8</code></span> if the register is RAX, and <span class="nowrap"><code>BC = 1 0 1 1 1 1 0 0</code></span>
if the register is R12. But what do we do with the first bit? After all, we need it to differentiate RAX and R8, which have the same
final 3 bits. We stick that one bit in the REX byte, which shows its purpose now. Finally, the <span class="nowrap"><code>io</code></span> tells us
that we need to stick 8 bytes on the end to store the <b>i</b>mmediate. The <span class="nowrap"><code>o</code></span> is what tells us we
need 8 bytes. Those 8 bytes will store the 64 bit constant used by this form of the MOV instruction.
</p></div><div class="content-paragraph"><p>
Let's try this out on <span class="nowrap"><code>MOV RCX, 45</code></span>. The REX byte will just be <span class="nowrap"><code>0 1 0 0 1 0 0 0</code></span>. The <span class="nowrap"><code>w</code></span> must be
set as long as we are using this form, but the rest are not since there is no call to use them. The <span class="nowrap"><code>B8 +rd</code></span> byte
actually becomes <span class="nowrap"><code>B8 + 01 = 1 0 1 1 1 0 0 1</code></span>. And the constant bytes are, byte-wise, <span class="nowrap"><code>2d 00 00 00 00 00 00 00</code></span>
since x86 and x64 is little-endian, where the lowest byte comes first. All together, that becomes <span class="nowrap"><code>48 B9 2d 00 00 00 00 00 00 00</code></span>.
Checking with an online disassembler confirms that this is indeed how you encode <span class="nowrap"><code>MOV RCX, 45</code></span> in bytes. 
</p></div><div class="content-paragraph"><p>
Returning to the final method of IEO I mentioned earlier, the secret to creating better assembly code lies in which form of 
an instruction you choose. If there is a form which is somehow shorter, then it's usually significantly better because it
saves time on the CPU decoding it, as well as the fact that shorter instructions means that more can be fit on one cache line.
In the case I've been talking about above, we can turn to an alternate, faster form for this instruction:  
</p></div><div class="content-code"><pre>
       Opcode       |    Instruction   |     |    Description
--------------------+------------------+ ... +--------------------
     B8 +rd id      |  MOV r32, imm32  |     | Move imm32 to r32
</pre></div><div class="content-paragraph"><p>
The major difference with this form is that it takes all 32 bit constants instead of 64 bit ones, it doesn't use a REX
byte, and it assigns to 32 bit registers. Each of those qualities is a benefit when compiling <span class="nowrap"><code>MOV RCX, 45</code></span>.
Since our constant doesn't actually need all 8 bytes, saving 4 bytes on the instruction size by going down to a 4 byte constant
cuts down on the instruction size by nearly 1/2. The omission of the REX byte results from the instruction using 32 bit registers,
which saves us another byte. Finally, x64 specifies that when a 32 bit register is mov'ed to, the top 32 bits of that register
are zeroed, which means that using a 32 bit and a 64 register are effectively identical for us.  
</p></div><div class="content-paragraph"><p>
When encoding <span class="nowrap"><code>MOV RCX, 45</code></span> according to this form instead of the previous form, the end result is 
<span class="nowrap"><code>B9 2d 00 00 00</code></span>, which is half the size yet does the exact same task. Therefore, choosing an instruction
encoding form is one of the most impactful things which can be done when doing IEO.
</p></div><div class="content-paragraph"><p>
But all this theory is for naught if it doesn't produce concrete gains in performance. So let's examine 4 cases. One will
use my JIT without optimization, one will use my JIT with optimization, and the final one will use Python. All will have 
identical effects, but differing times.
</p></div><div class="content-paragraph"><p>
First case: my JIT without optimization. The code I handed the JIT was this:
</p></div><div class="content-code"><pre>
def main(a1) {
    let a2 =  a1  + 3;
    let a3 =  a2  + 3;
    let a4 =  a3  + 3;
    let a5 =  a4  + 3;
    let a6 =  a5  + 3;
    let a7 =  a6  + 3;
    let a8 =  a7  + 3;
    let a9 =  a8  + 3;
    let a10 = a9  + 3;
    let a11 = a10 + 3;
    let a12 = a11 + 3;
    return    a12 + 3;
}
</pre></div><div class="content-paragraph"><p>
Below is the generated assembly code, in the encoded and textual forms: 
</p></div><div class="content-code"><pre>
48b803000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c848b903000000000000004801c8c3

mov rax,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
mov rcx,0x3
add rax,rcx
ret
</pre></div><div class="content-paragraph"><p>
This is 205 bytes long. The code takes an average of 6 nanoseconds to execute. 
</p></div><div class="content-paragraph"><p>
When optimizations are turned on, the following assembly is generated: 
</p></div><div class="content-code"><pre>
4889c80424c3

mov rax,rcx
add al,0x24
ret
</pre></div><div class="content-paragraph"><p>
This is 6 bytes long. The code takes an average of 4 nanoseconds to execute. Although the code-size reduction is obviously 
impressive, the speed improvement doesn't look as impressive. In reality, that the code is probably even faster than it
appears because the overhead from the timing function. Additionally, many professional teams would sell their souls for
just a 10% improvement in their JIT speed-ups, sp a 33% improvement is very important. However, these numbers don't have any
meaning if this is actually 1000% slower than the alternatives to my JIT. So, let's look at the numbers for Python.
</p></div><div class="content-paragraph"><p>
I've written the following Python code, which does the exact same task the code for the JIT does:
</p></div><div class="content-code"><pre>
def main(a1):
    a2 =   a1  + 3
    a3 =   a2  + 3
    a4 =   a3  + 3
    a5 =   a4  + 3
    a6 =   a5  + 3
    a7 =   a6  + 3
    a8 =   a7  + 3
    a9 =   a8  + 3
    a10 =  a9  + 3
    a11 =  a10 + 3
    a12 =  a11 + 3
    return a12 + 3
</pre></div><div class="content-paragraph"><p>
This code takes an average of 1663 nanoseconds to execute a single iteration of the function. This means that my full 
JIT with optimizations is a 99.76% speed-up, or a 415.75x speed-up. All of these are excellent numbers, in my estimation,
so I'd say I'm doing pretty well.
</p></div><div class="content-heading">Reflection</div><div class="content-paragraph"><p>
Most of the work I did on the optimizations was done over the course of a week where I didn't have much to do for other
classes, except for 3 essays for AP Euro which I've since turned in. This gives me hope that I can fit work on my Senior
Project into my otherwise busy schedule.</p></div><div class="content-paragraph"><p>This is definitely the most fun I've had writing a journal, which is why its so much longer than the previous ones,
and why it's slightly delayed. Even with all this text, I still haven't covered everything I wanted to. I'm working on an 
addendum like the <a href="/jit-project/about.html">About</a> page, except covering the clever? way I've found to make
Dead Code Elimination come for free and Register Allocation significantly smarter (hint: go through the SSA-form IR backwards).</p></div><div class="content-paragraph"><p>I'm not entirely sure what my future work on my project looks like. There's the obvious steps, like make the JIT usable
with support for loops, data types, and objects. Of course, once I implement those, I can get to the JIT parts of my JIT,
since support for those features was why JITs were invented. </p></div><div class="content-paragraph"><p>However, the hopes for Python integration look like a lot of extra work now that I've looked into parsing support more. 
The Python -> JIT step would be easy is there was any way to get Python parsing outside of Python. And if I have to lug 
the entire Python Binary and Standard Library just to get interop with it, what's the point? </p></div><div class="content-paragraph"><p>The really challenging parts of my project would be bringing it to a professional quality and giving it a Standard Library.
Both are some of the dullest things to do, but also the most important parts if you want public support for a programming
language implementation. It seems I won't do them though, because it would honestly be a pretty dumb to invest 3+ years of work
into a learning project. I don't want anyone to use this language. Already, I know things I'd do different if I was just
starting this project, like the choice of programming language.</p></div><div class="content-paragraph"><p>So, my standard for the completion of this project is if I can make it again in itself, which is a fairly common standard 
for programming language projects. I believe this will be an achievable, if challenging, goal.</p></div><div class="content-paragraph"><p>P.S. I added a usable mobile interface for this site if you want to check it out. Improvement coming there soon based on the
feedback of an unnamed student.
</p></div><div class="content-heading">Main Accomplishments</div><ol class="content-ordered-list"><li class="content-ordered-list-item"><div class="content-paragraph"><p>Added JIT wrapper</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Instruction Selection Optimization</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Added subtract and function calls</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Added Constant Folding</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Added memory management</p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p>Refactored code to facilitate further development</p></div></li></ol><div class="content-heading">Sources:</div><ol class="content-ordered-list"><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">x64 Instruction Reference</a></p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="https://pyokagan.name/blog/2019-09-20-x86encoding/">Reference on x64 encoding #1</a></p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="http://ref.x86asm.net/geek64.html">Reference on x64 encoding #2</a></p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="https://wiki.osdev.org/X86-64_Instruction_Encoding">Reference on x64 encoding #3</a></p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="https://en.wikipedia.org/wiki/Constant_folding">Wikipedia explaining the principles behind constant folding</a></p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="https://en.wikipedia.org/wiki/Dead_code_elimination">Wikipedia explaining the principles behind Dead Code Elimination</a></p></div></li><li class="content-ordered-list-item"><div class="content-paragraph"><p><a href="https://en.wikipedia.org/wiki/Instruction_selection">Wikipedia explaining the principles behind Instruction Emission</a></p></div></li></ol><div class="content-end"></div>
        </div>
    </div>
    <div class="right-content"></div>
</body>
</html>